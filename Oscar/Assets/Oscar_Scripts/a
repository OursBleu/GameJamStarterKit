using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;

public class Fsm : MonoBehaviour
{
    private int _lastUsedIndex = 0;

    private Dictionary<int, State> _states;
    protected Dictionary<int, State> States { get { return _states; } set { _states = value; } }

    private Dictionary<State, List<Func<State>>> _transitions;

    private State _currentState;
    protected State CurrentState { get { return _currentState; } set { _currentState = value; } }

    private State _nextState;

    private float _elapsedTime;
    public float ElapsedTime { get { return _elapsedTime; } }

    protected virtual void Awake()
    {
        _states = new Dictionary<int, State>();
        _transitions = new Dictionary<State, List<Func<State>>>();
    }

    protected virtual void Update()
    {
        _currentState.StateUpdate();
        CheckForTransitions();
        if (_nextState != null) AdvanceToNextState();
    }

    protected virtual void LateUpdate()
    {
        _elapsedTime += Time.deltaTime;
    }


    protected int AddState(State value)
    {
        int _currentIndex = _lastUsedIndex;
        _lastUsedIndex += 1;

        _states.Add((_currentIndex), value);
        _transitions.Add(value, new List<Func<State>>());
        value.Fsm = this;

        return (_currentIndex);
    }

    //ne marche pas car on ne peux pas faire new T(this)
    protected int AddState<T>() where T : State, new()
    {
        return AddState(new T());
    }

    protected void AddTransition(int currentState, int nextState, Func<bool> test)
    {
        Func<State> transition = () => { if (test()) return States[nextState]; else return CurrentState; };
        _transitions[_states[currentState]].Add(transition);
    }

    protected void AddTransition(int[] selectedStates, int nextState, Func<bool> test, bool reverse=false)
    {
        Func<State> transition = () => { if (test()) return States[nextState]; else return CurrentState; };

        foreach (int state in States.Keys)
        {
            if (!reverse && Array.IndexOf(selectedStates, state) != -1) _transitions[States[state]].Add(transition);
            else if (reverse && Array.IndexOf(selectedStates, state) == -1) _transitions[States[state]].Add(transition);
        }
    }

    protected void SetFirstState(int firstState)
    {
        _currentState = States[firstState];
        _currentState.StateEnter();
    }

    private void AdvanceToNextState()
    {
        if (_nextState == _currentState) return;

        Debug.Log(_nextState);

        _currentState.StateExit();

        _elapsedTime = 0f;
        _currentState = _nextState;
        _nextState = null;

        _currentState.StateEnter();
    }

    private void CheckForTransitions()
    {
        foreach (Func<State> transition in _transitions[_currentState])
        {
            _nextState = transition();
            if (_nextState != _currentState) break;
        }
    }

}


public struct StateInfo
{
    public List<Func<State>> transitions;
    public List<Action<string>> effects;
}
